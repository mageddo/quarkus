////
This guide is maintained in the main Quarkus repository
and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
////
= Quarkus - Application Data Caching

include::./attributes.adoc[]

In this guide, you will learn how to enable application data caching on any CDI managed bean in Quarkus.

== Prerequisites

To complete this guide, you need:

* less than 15 minutes
* an IDE
* JDK 1.8+ installed with `JAVA_HOME` configured appropriately
* Apache Maven 3.5.3+

== Scenario

Let's imagine you want to expose in your Quarkus application a REST API that allows users to retrieve the weather forecast for
the next three days. The problem is that you have to rely on an external meteorological service which only accepts requests for
one day at a time and takes forever to answer. Since the weather forecast is updated once every twelve hours, caching the
service responses would definitely improve your API performances.

We'll do that using a single Quarkus annotation.

== Solution

We recommend that you follow the instructions in the next sections and create the application step by step.
However, you can go right to the completed example.

Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].

The solution is located in the `application-data-caching` directory.

== Creating the Maven project

First, we need a new Quarkus project. Create it with the following command:

[source,shell,subs=attributes+]
----
mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=application-data-caching \
    -DclassName="org.acme.caching.WeatherForecastResource" \
    -Dpath="/weather" \
    -Dextensions="cache,resteasy-jsonb"
----

This command generates the Maven project with a REST endpoint and imports the `cache` and `resteasy-jsonb` extensions.

== Creating the REST API

Let's start by creating a service that will simulate an extremely slow call to the external meteorological service. Create
`src/main/java/org/acme/caching/WeatherForecastService.java` with the following content:

[source,java]
----
package org.acme.caching;

import java.time.LocalDate;

import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class WeatherForecastService {

    public String getDailyForecast(LocalDate date, String city) {
        try {
            Thread.sleep(2000L); <1>
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return date.getDayOfWeek() + " will be " + getDailyResult(date.getDayOfMonth() % 4) + " in " + city;
    }

    private String getDailyResult(int dayOfMonthModuloFour) {
        switch (dayOfMonthModuloFour) {
            case 0:
                return "sunny";
            case 1:
                return "cloudy";
            case 2:
                return "chilly";
            case 3:
                return "rainy";
            default:
                throw new IllegalArgumentException();
        }
    }
}
----
<1> This is where the slowness comes from.

We also need a class that will contain the response sent to the user when he asks for the next three days weather forecast.
Create `src/main/java/org/acme/caching/WeatherForecast.java` this way:

[source,java]
----
package org.acme.caching;

import java.util.List;

public class WeatherForecast {

    private List<String> dailyForecasts;

    private long executionTimeInMs;

    public WeatherForecast(List<String> dailyForecasts, long executionTimeInMs) {
        this.dailyForecasts = dailyForecasts;
        this.executionTimeInMs = executionTimeInMs;
    }

    public List<String> getDailyForecasts() {
        return dailyForecasts;
    }

    public long getExecutionTimeInMs() {
        return executionTimeInMs;
    }
}
----

Now, we just need to update the generated `WeatherForecastResource` to use the service and response:

[source,java]
----
package org.acme.caching;

import java.time.LocalDate;
import java.util.Arrays;
import java.util.List;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.MediaType;

@Path("/weather")
public class WeatherForecastResource {

    @Inject
    WeatherForecastService service;

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public WeatherForecast getForecast(@QueryParam("city") String city) {
        long executionStart = System.currentTimeMillis();
        List<String> dailyForecasts = Arrays.asList(
                service.getDailyForecast(LocalDate.now(), city), <1>
                service.getDailyForecast(LocalDate.now().plusDays(1L), city), <2>
                service.getDailyForecast(LocalDate.now().plusDays(2L), city) <3>
        );
        long executionEnd = System.currentTimeMillis();
        return new WeatherForecast(dailyForecasts, executionEnd - executionStart);
    }
}
----
<1> This will retrieve the weather forecast for today.
<2> Same thing for tomorrow.
<3> And the day after tomorrow.

We're all done! Let's check if everything's working.

First, run the application using `./mvnw compile quarkus:dev` from the project directory.

Then, call `http://localhost:8080/weather?city=Raleigh` from a browser. After six long seconds, the application will answer
something like this:

[source]
----
{"dailyForecasts":["MONDAY will be cloudy in Raleigh","TUESDAY will be chilly in Raleigh","WEDNESDAY will be rainy in Raleigh"],"executionTimeInMs":6001}
----

[TIP]
====
The response content may vary depending on the day you run the code.
====

You can try calling the same URL again and again, it will always take six seconds to answer.

== Enabling the cache

Now that your Quarkus application is up and running, let's tremendously improve its response time by caching the external
meteorological service responses. Update the `WeatherForecastService` class like this:

[source,java]
----
package org.acme.caching;

import java.time.LocalDate;

import javax.enterprise.context.ApplicationScoped;

import io.quarkus.cache.CacheLoad;

@ApplicationScoped
public class WeatherForecastService {

    @CacheLoad <1>
    public String getDailyForecast(LocalDate date, String city) {
        try {
            Thread.sleep(2000L);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return date.getDayOfWeek() + " will be " + getDailyResult(date.getDayOfMonth() % 4) + " in " + city;
    }

    private String getDailyResult(int dayOfMonthModuloFour) {
        switch (dayOfMonthModuloFour) {
            case 0:
                return "sunny";
            case 1:
                return "cloudy";
            case 2:
                return "chilly";
            case 3:
                return "rainy";
            default:
                throw new IllegalArgumentException();
        }
    }
}
----
<1> We only added this annotation (and the associated import of course).

Let's try to call `http://localhost:8080/weather?city=Raleigh` again. You're still waiting a long time before receiving an
answer. This is normal since the server just restarted and the cache was empty.

Wait a second! The server restarted by itself after the `WeatherForecastService` update? Yes, this is one of Quarkus amazing
features for developers called `hot reload`.

Now that the cache was loaded during the previous call, let's try it again. This time, you should get a super fast answer with
an `executionTimeInMs` value close to zero.

You can also try calling the same URL with a different city and see the cache in action again. The first call will take six
seconds and the following ones will be answered immediately.  

Congratulations, you just added the application data cache to your Quarkus application with a single line of code!

Do you want to learn more about the Quarkus application data caching abilities? The following sections will show you everything
there is to know about it.

== Caching annotations

Quarkus offers four method-level annotations and one parameter-level annotation that can be used on a CDI managed bean to
enable caching abilities:

=== @CacheLoad

When a method annotated with `@CacheLoad` is invoked, Quarkus will check in the cache whether the method has been already
invoked for the given arguments. This check is done using a cache key computed from all the method arguments if none of them is
annotated with `@CacheKey`, or all the arguments annotated with `@CacheKey` otherwise. If a value is found in the cache, it
is returned and the annotated method is never actually executed. If no value is found, the annotated method is invoked and the
returned value is stored in the cache using the computed key.

This annotation can't be used on methods returning `void` and requires at least one method argument to compute the key.

=== @CacheStore

When a method annotated with `@CacheStore` is invoked, Quarkus will cache its return value at the end of the invocation. The
caching is done using a cache key computed from all the method arguments if none of them is annotated with `@CacheKey`, or all
the arguments annotated with `@CacheKey` otherwise. If a value is already present in the cache for the computed key, it is
replaced.

This annotation can't be used on methods returning `void` and requires at least one method argument to compute the

=== @CacheInvalidate

When a method annotated with `@CacheInvalidate` is invoked, Quarkus will try to remove an existing entry from the cache. This
removal is done using a cache key computed from all the method arguments if none of them is annotated with `@CacheKey`, or all
the arguments annotated with `@CacheKey` otherwise. If the key does not identify any cache entry, nothing will happen.

This annotation requires at least one method argument to compute the key.

=== @CacheInvalidateAll

When a method annotated with `@CacheInvalidateAll` is invoked, Quarkus will remove all entries from the cache.

=== @CacheKey

When a method argument is annotated with `@CacheKey`, it is identified as a part of a cache key during an invocation of a
method annotated with `@CacheLoad`, `@CacheStore` or `@CacheInvalidate`.

This annotation is optional and should only be used when some of the method arguments are NOT part of the cache key.

== Configuring the underlying caching provider

For now, https://github.com/ben-manes/caffeine[Caffeine] is the only available local caching provider in Quarkus. We plan to
add more providers soon.

=== Caffeine configuration properties

Caffeine is a high performance, near optimal caching library based on Java 8.






Each underlying cache

 It can be configured in Quarkus by adding the
following properties to the `application.properties` file.







The following properties can be added to the Quarkus `application.properties` file to configure a Caffeine cache named
`cache-name`. You can replace.

`quarkus.cache.caffeine.namespace."cache-name".initial-capacity`::
Minimum total size for the internal data structures. Providing a large enough estimate at construction time avoids the need for
expensive resizing operations later, but setting this value unnecessarily high wastes memory.

`quarkus.cache.caffeine.namespace."cache-name".maximum-size`::
Maximum number of entries the cache may contain. Note that the cache may evict an entry before this limit is exceeded or
temporarily exceed the threshold while evicting. As the cache size grows close to the maximum, the cache evicts entries that
are less likely to be used again. For example, the cache may evict an entry because it hasn't been used recently or very often.

`quarkus.cache.caffeine.namespace."cache-name".expire-after-write`::
Specifies that each entry should be automatically removed from the cache once a fixed duration has elapsed after the entry's
creation, or the most recent replacement of its value.

`quarkus.cache.caffeine.namespace."cache-name".expire-after-access`::
Specifies that each entry should be automatically removed from the cache once a fixed duration has elapsed after the entry's
creation, the most recent replacement of its value, or its last read.

Here's an example of Caffeine cache configuration:

[source,properties]
----
quarkus.cache.caffeine.namespace."toto".initial-capacity=10 <1>
quarkus.cache.caffeine.namespace."toto".maximum-suze=100
etc
second cache aussi <2>
----
<1> expl
<2> expl






TODO: changer la date d'un jour ?
